const std = @import("std");
const Step = std.Build.Step;

const StaticPluginStep = @This();

step: Step,
output_file: std.Build.GeneratedFile,
static_plugins: []const []const u8,

pub const base_id: Step.Id = .custom;

pub const Options = struct {
    static_plugins: []const []const u8 = &.{},
};

pub fn create(owner: *std.Build, options: Options) *StaticPluginStep {
    const self = owner.allocator.create(StaticPluginStep) catch @panic("OOM");

    self.* = .{
        .step = Step.init(.{
            .id = base_id,
            .name = "Generate Wwise static plugin C build file",
            .owner = owner,
            .makeFn = make,
            .first_ret_addr = @returnAddress(),
        }),
        .static_plugins = options.static_plugins,
        .output_file = .{ .step = &self.step },
    };

    return self;
}

fn make(step: *Step, prog_node: *std.Progress.Node) !void {
    _ = prog_node;
    const b = step.owner;
    const self = @fieldParentPtr(StaticPluginStep, "step", step);
    const gpa = b.allocator;
    const arena = b.allocator;

    var man = b.cache.obtain();
    defer man.deinit();

    // Random bytes to make StaticPluginStep unique. Refresh this with new
    // random bytes when StaticPluginStep implementation is modified in a
    // non-backwards-compatible way.
    man.hash.add(@as(u32, 0xc01db1e5));

    var output = std.ArrayList(u8).init(gpa);
    defer output.deinit();

    const file_name = "wwise_c_static_plugins.cpp";

    try output.appendSlice("// This file was generated by Wwise Static Plugin Step using the Zig Build System.\n");
    try output.appendSlice("#include <AK/AkPlatforms.h>\n");
    try output.appendSlice("#include <AK/SoundEngine/Common/AkTypes.h>\n");
    try output.appendSlice("#include <AK/SoundEngine/Common/IAkPlugin.h>\n\n");
    try output.appendSlice("extern \"C\" void WWISEC_HACK_RegisterAllPlugins() {{}}\n");

    const writer = output.writer();

    for (self.static_plugins) |static_plugin| {
        try writer.print("#include <AK/Plugin/{s}Factory.h>\n", .{static_plugin});
    }

    man.hash.addBytes(output.items);

    if (try step.cacheHit(&man)) {
        const digest = man.final();
        self.output_file.path = try b.cache_root.join(arena, &.{
            "o", &digest, file_name,
        });
        return;
    }

    const digest = man.final();

    const sub_path = try std.fs.path.join(arena, &.{ "o", &digest, file_name });
    const sub_path_dirname = std.fs.path.dirname(sub_path).?;

    b.cache_root.handle.makePath(sub_path_dirname) catch |err| {
        return step.fail("unable to make path '{}{s}': {s}", .{
            b.cache_root, sub_path_dirname, @errorName(err),
        });
    };

    b.cache_root.handle.writeFile(sub_path, output.items) catch |err| {
        return step.fail("unable to write file '{}{s}': {s}", .{
            b.cache_root, sub_path, @errorName(err),
        });
    };

    self.output_file.path = try b.cache_root.join(arena, &.{sub_path});
    try man.writeManifest();
}
